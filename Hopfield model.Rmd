---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.10.2
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
import numpy as np
import matplotlib.pyplot as plt
```

```{python}
N = 3000 #Number of neurons
L = 16 #Number of patterns

f = 0.1 #Sparseness
```

```{python}
patterns = np.zeros((L, N), dtype=int)
mask = np.random.uniform(0, 1, size=(L, N)) < f
patterns[mask] = 1
```

```{python}
synaptic_mtx = 1./(N * f * (1.-f)) * ((patterns - f).T @ (patterns - f))
```

```{python}
T = 0.015 #Thresholds are uniformely sampled from the interval [-T, T]

init_thresholds = np.random.uniform(-T, T, size=N)

Dth = 1.9 * T #Amplitude of threshold adaptation
Tth = 45 #Timescale of adaptation

n_steps = 1000
ts = np.arange(n_steps) #time steps

J0min = 0.7 #Minimum value for J0 (global inhibition)
J0max = 1.2 #Maximum value for J0
TJ0   = 25  #Period for J0 oscillations between min and max

J0 = np.sin(2 * np.pi / TJ0 * ts) * (J0max - J0min) + J0min #(oscillating) global inhibition
```

```{python}
def order_params(neuro_state):
    return (patterns - f) @ neuro_state / (N * f * (1.-f))
```

```{python}
neuro_order_states = np.zeros((L, n_steps)) #Store order parameters at each time here
```

```{python}
from tqdm.notebook import tqdm
```

```{python}
curr_thresholds = init_thresholds.copy()
curr_neuro_state = patterns[0].copy() #initialize to 1st pattern

for idx, t in enumerate(tqdm(ts)):
    next_neuro_state = synaptic_mtx @ curr_neuro_state - J0[idx] / (N * f) * np.sum(curr_neuro_state) - curr_thresholds
    next_neuro_state = np.heaviside(next_neuro_state, 0)
    
    next_thresholds = curr_thresholds - (curr_thresholds - init_thresholds - Dth * curr_neuro_state) / Tth
    
    curr_neuro_state = next_neuro_state.copy()
    curr_thresholds  = next_thresholds.copy()
    
    neuro_order_states[:, idx] = order_params(curr_neuro_state)
    print(curr_neuro_state.sum())
    
    #whyyyyyy
```

```{python}
curr_neuro_state
```

```{python}
plt.imshow(neuro_order_states, aspect='auto', cmap='viridis')
```

```{python}
overlaps = patterns @ patterns.T
average_entries = (np.sum(overlaps, axis=1) - np.diag(overlaps)) / (L - 1)
np.fill_diagonal(overlaps, average_entries) #Substitute in the diagonal the average value of the other entries
```

```{python}
plt.imshow(overlaps)
```

```{python}
overlaps
```

```{python}
order_params(curr_neuro_state)
```

```{python}
neuro_state.sum()
```

```{python}

```
